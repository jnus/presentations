Function Get-TfsWorkItemInIteration
{
    <#
        .SYNOPSIS
            This function gets any work items in the specified Iteration

        .DESCRIPTION
            This function gets any work items in the specified iteration.

            The function accepts input from the pipeline in the form of a WebSession object, such as generated by the Connect-TfsServer
            function.

        .PARAMETER IterationPath
            The exact path of the iteration to look up, such as 'test\Sprint 1'

        .PARAMETER IdOnly
            Switch that will cause function to only return the Ids of the Work Items

        .PARAMETER IncludeClosed
            Switch that will cause function to also return closed work items

        .EXAMPLE
            Get-TfsWorkItemInIteration -Uri https://test.visualstudio.com/DefaultCollection -Username username@email.com -AccessToken (Get-Content C:\AccessToken.txt) -IterationPath 'Test\Sprint 1'

            This will get all the work items in Sprint 1 of the Test project that are in the New state, using the specified credentials and Uri.

        .EXAMPLE
            Get-TfsWorkItemInIteration -WebSession $Session -IterationPath 'Test\Sprint 4'
            
            This will get all the work items in Sprint 4 of the Test project with the New or Approved state, using the WebSession object for the Uri and credentials.

        .EXAMPLE
            Connect-TfsServer -Uri "https://test.visualstudio.com/DefaultCollection  -Username username@email.com -AccessToken (Get-Content C:\AccessToken.txt) |  Get-TfsWorkItemInIterationWithNoTask -IterationPath 'Test\Sprint 4'
            
            This will connect to the specified TFS server and then pass the WebSession object into the pipeline and get all the work items in Sprint 4 of the Test project.
    #>
    [cmdletbinding()]
    param
    (
        [Parameter(Mandatory)]
        [String]$IterationPath,

        [switch]$IdOnly,

        [switch]$IncludeClosed

    )
    Process
    {
        $headers = @{'Content-Type'='application/json'}
        $Parameters = @{}
        $Parameters.add('WebSession',$WebSession)
        $Parameters.add('Headers',$headers)  
        
        write-verbose "Getting Backlog Items under $iterationpath via $uri that have no child tasks" 

        $queryuri = "$($uri)/_apis/wit/wiql?api-version=1.0"
        if ($IncludeClosed)
        {
            $wiq = "SELECT [System.Id], [System.Links.LinkType], [System.WorkItemType], [System.Title], [System.AssignedTo], [System.State], [System.Tags] FROM WorkItemLinks WHERE ([Source].[System.IterationPath] UNDER '$iterationpath') And ([System.Links.LinkType] <> '') And ([Target].[System.WorkItemType] IN GROUP 'Microsoft.RequirementCategory') ORDER BY [System.Id] mode(MayContain)"
        }
        else
        {
            $wiq = "SELECT [System.Id], [System.Links.LinkType], [System.WorkItemType], [System.Title], [System.AssignedTo], [System.State], [System.Tags] FROM WorkItemLinks WHERE ([Source].[System.IterationPath] UNDER '$iterationpath') And ([Source].[System.State] <> 'Done') And ([Source].[System.State] <> 'Removed') And ([System.Links.LinkType] <> '') And ([Target].[System.WorkItemType] IN GROUP 'Microsoft.RequirementCategory') ORDER BY [System.Id] mode(MayContain)"
        }
        $data = @{query = $wiq } | ConvertTo-Json

        $Parameters.add('Uri', $queryUri)

        Try
        {
            $jsondata = Invoke-RestMethod  @parameters -Method Post -Body $data -ErrorAction Stop
        }
        catch
        {
            Throw
        }

        if ($IdOnly)
        {
            Write-Output $jsondata.workItemRelations.target | Select-Object -ExpandProperty Id -Unique
        }
        else
        {
            Write-Output $jsondata
        }
    }
}
