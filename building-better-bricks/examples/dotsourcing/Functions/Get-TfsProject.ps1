function Get-TfsProject
{
    <#
        .SYNOPSIS
            This function gets a list of TFS team projects

        .DESCRIPTION
            This function gets a list of all the team projects from
            the target TFS server that the user has access to.

            The function will take either a websession object or a uri and
            credentials. The web session can be piped to the fuction from the
            Connect-TfsServer function.

        .PARAMETER WebSession
            Websession with connection details and credentials generated by Connect-TfsServer function

        .PARAMETER Uri
            Uri of TFS serverm, including /DefaultCollection (or equivilent)

        .PARAMETER Username
            The username to connect to the remote server with

        .PARAMETER AccessToken
            Access token for the username connecting to the remote server

        .PARAMETER UseDefaultCredentails
            Switch to use the logged in users credentials for authenticating with TFS.

        .PARAMETER Project
            Get details of a specific project.

        .PARAMETER IncludeCapabilities
            Get full details of a project, include source control method used and process template.

        .EXAMPLE
            Get-TfsTeamProject -WebSession $Session

            This will get all the Projects that the user in the Web Session object has access to.

        .EXAMPLE
            Get-TfsTeamProject -Uri 'https://test.visualstudio.com/DefaultCollection'  -Username username@email.com -AccessToken (Get-Content C:\AccessToken.txt)

            This will get all the Projects that the user has access to.
    #>
    [cmdletbinding()]
    param
    (
        [Parameter(ParameterSetName='WebSession', Mandatory,ValueFromPipeline)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$WebSession,

        [Parameter(ParameterSetName='SingleConnection',Mandatory)]
        [Parameter(ParameterSetName='LocalConnection',Mandatory)]
        [String]$uri,

        [Parameter(ParameterSetName='SingleConnection',Mandatory)]
        [string]$Username,

        [Parameter(ParameterSetName='SingleConnection',Mandatory)]
        [string]$AccessToken,

        [parameter(ParameterSetName='LocalConnection',Mandatory)]
        [switch]$UseDefaultCredentials,

        [string]$Project,

        [switch]$IncludeCapabilities

    )

    Process
    {
        $headers = @{'Content-Type'='application/json'}
        $Parameters = @{}

        #Use Hashtable to create param block for invoke-restmethod and splat it together
        switch ($PsCmdlet.ParameterSetName) 
        {
            'SingleConnection'
            {
                $WebSession = Connect-TfsServer -Uri $uri -Username $Username -AccessToken $AccessToken
                $Parameters.add('WebSession',$WebSession)
                $Parameters.add('Headers',$headers)

            }
            'LocalConnection'
            {
                $WebSession = Connect-TfsServer -uri $Uri -UseDefaultCredentials
                $Parameters.add('WebSession',$WebSession)
                $Parameters.add('Headers',$headers)
            }
            'WebSession'
            {
                $Uri = $WebSession.uri
                $Parameters.add('WebSession',$WebSession)
                $Parameters.add('Headers',$headers)
                #Connection details here from websession, no creds needed as already there
            }
        
        }    

        #create the REST url
        if ($Project)
        {
            $uri = "$uri/_apis/projects/$($Project)?api-version=1.0"
            if ($IncludeCapabilities)
            {
                $Uri = "$Uri&includeCapabilities=true"
            }
        }
        else
        {
            $uri = "$uri/_apis/projects?api-version=1.0"
        }
        
        $parameters.add('Uri',$uri)

        #Attempt to get the data from the Rest API
        try
        {
            $jsondata = Invoke-RestMethod @Parameters -ErrorAction Stop
        }
        catch
        {
            Throw
        }
        
        #Output data to the pipeline
        if ($jsondata.count -gt 0)
        {
            write-output $jsondata.value
        }
        else
        {
            Write-Output $jsondata 
        }
    
    }
}
